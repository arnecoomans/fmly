from xml.dom.minidom import Document
from django.db import models
from django.urls import reverse, reverse_lazy
from django.contrib.auth.models import User
from django.template.defaultfilters import slugify




# Create Thumbnail function
def get_thumbnail(image):
  # Check if suffix is supported.
  if image.name[-4:].lower() not in ['.jpg', '.png'] and image.name[-5:].lower() not in ['.jpeg',]:
    return 'unsupported image'
  import base64
  from io import BytesIO
  from PIL import Image, ImageOps
  Image.MAX_IMAGE_PIXELS = 933120000

  thumbnail_size = 150, 300
  data_img = BytesIO()
  tiny_img = Image.open(image)
  tiny_img = ImageOps.exif_transpose(tiny_img)
  tiny_img.thumbnail(thumbnail_size)
  tiny_img.save(data_img, format="BMP")
  tiny_img.close()
  try:
      return "data:image/jpg;base64,{}".format(
          base64.b64encode(data_img.getvalue()).decode("utf-8")
      )
  except UnicodeDecodeError:
      return 'decode_error'


class Person(models.Model):
  first_name          = models.CharField(max_length=255, blank=True, verbose_name='Roepnaam')
  given_names         = models.CharField(max_length=255, blank=True, verbose_name='Voornamen', help_text='Alle voornamen, inclusief roepnaam')
  last_name           = models.CharField(max_length=255, blank=True, verbose_name='Achternaam')
  nickname            = models.CharField(max_length=255, blank=True, verbose_name='Bijnaam')
  email               = models.EmailField(blank=True, help_text='Dit veld is alleen zichtbaar voor jou en voor de site-beheerder(s). Vul je e-mailadres in zodat we je een wachtwoord-reset email kunnen sturen als je niet langer kan inloggen.')
  slug                = models.CharField(max_length=255, unique=True)
  # Information
  place_of_birth      = models.CharField(max_length=255, blank=True)
  place_of_death      = models.CharField(max_length=255, blank=True)
  # Dating
  date_of_birth       = models.DateField(null=True, blank=True, help_text='Format: year-month-date, for example 1981-08-11')
  year_of_birth       = models.PositiveSmallIntegerField(blank=True, null=True, help_text='Is automatically filled when date is supplied')
  date_of_death       = models.DateField(null=True, blank=True, help_text='Format: year-month-date, for example 1981-08-11')
  year_of_death       = models.PositiveSmallIntegerField(blank=True, null=True, help_text='Is automatically filled when date is supplied')
  # Bio
  #portrait            = models.ForeignKey(Image, on_delete=models.CASCADE, blank=True)
  bio                 = models.TextField(blank=True, help_text='Markdown supported')
  # Meta
  related_user        = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, related_name='related_person')
  user                = models.ForeignKey(User, on_delete=models.CASCADE)
  
  def __str__(self):
    value = self.full_name()
    if self.year_of_birth or self.year_of_death:
        value += ' ('
        value += str(self.year_of_birth) if self.year_of_birth else ' '
        value += ' - '
        value += str(self.year_of_death) if self.year_of_death else ' '
        value += ')'
    return value

  def name(self):
    return ' '.join([self.first_name, self.last_name])

  def full_name(self):
    call_sign = ''
    if self.first_name not in self.given_names.split(' '):
      call_sign = '(' + self.first_name + ') '
    return ' '.join([call_sign, self.given_names, self.last_name])

  def get_first_name(self):
    return self.first_name if self.first_name not in self.given_names else None

  def age(self):
    if self.date_of_birth and self.date_of_death:
      age = self.date_of_death.year - self.date_of_birth.year
      age -= ((self.date_of_birth.month, self.date_of_birth.day) <
         (self.date_of_birth.month, self.date_of_birth.day))
      return age
    elif self.year_of_birth and self.year_of_death:
      return self.year_of_death - self.year_of_birth

  def get_parents(self):
    if self.relation_up:
      parents = []
      for parent in self.relation_up.filter(type='parent').order_by('up__year_of_birth'):
        parents.append(parent.up)
      return parents

  def get_children(self):
    if self.relation_down:
      children = []
      for child in self.relation_down.filter(type='parent').order_by('down__year_of_birth'):
        children.append(child.down)
      return children
  
  def get_partners(self):
    if self.relation_down:
      partners = []
      for child in self.relation_down.filter(type='parent'):
        for parent in child.down.relation_up.filter(type='parent'):
          if parent.up not in partners and parent.up != self:
            partners.append(parent.up)
      for partner in self.relation_up.filter(type='partner'):
        partners.append(partner.up)
      for partner in self.relation_down.filter(type='partner'):
        partners.append(partner.down)
      return partners

  def get_siblings(self):
    if self.relation_up:
      siblings = []
      for parent in self.relation_up.filter(type='parent'):
        for child in parent.up.relation_down.all():
          if child.down not in siblings and child.down != self:
            siblings.append(child.down)
      return siblings

  class Meta:
    ordering = ('last_name', 'first_name')
  
  def get_absolute_url(self):
    return reverse('archive:person', kwargs={'pk':self.id, 'name': self.slug})
  
  def save(self, *args, **kwargs):
    # Ensure there is a first name. If no first name is mentioned,
    # use the first word from given name
    if self.given_names and not self.first_name:
      if ' ' in self.given_names:
        self.first_name = self.given_names.split()[1]
      else:
        self.first_name = self.given_names
    # Set user
    if not self.user:
      self.user = request.user
    if not self.year_of_birth and self.date_of_birth:
      self.year_of_birth = int(self.date_of_birth.year)
    if not self.year_of_death and self.date_of_death:
      self.year_of_death = int(self.date_of_death.year)
    if Person.objects.filter(slug=self.slug).count() > 1:
      slug = ' '.join(self.given_names, self.last_name) + '('
      if self.year_of_birth:
        slug += str(self.year_of_birth)
      slug += '-'
      if self.year_of_death:
        slug += self.year_of_death
      slug += ')'
      self.slug = slugify(slug)
    if self.related_user and self.first_name:
      self.related_user.first_name = self.first_name
    if self.related_user and self.last_name:
      self.related_user.last_name = self.last_name
    if self.related_user and self.email:
      self.related_user.email = self.email
    if self.related_user:
      self.related_user.save()
    return super(Person, self).save(*args, **kwargs)

class FamilyRelations(models.Model):
  RELATION_CHOICES = [
    ('parent', 'Parent'),
    ('partner', 'Partner'),
  ]
  up                  = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='relation_down')
  down                = models.ForeignKey(Person, on_delete=models.CASCADE, related_name='relation_up')
  type                = models.CharField(choices=RELATION_CHOICES, max_length=16, default='parent')

  def __str__(self):
    return str(self.up) + ' is ' + self.type + ' of ' + str(self.down)

class Tag(models.Model):
  title               = models.CharField(max_length=255)
  slug                = models.SlugField(unique=True)
  def __str__(self):
    return self.title
  class Meta:
        ordering = (['title'])
  # Save all tags as lowercase. Use |title in the template for displaying  
  def save(self, *args, **kwargs):
    self.title = self.title.lower()
    self.slug = slugify(self.title)
    return super(Tag, self).save(*args, **kwargs)
  def get_absolute_url(self):
    return reverse_lazy('archive:tag', kwargs={'slug': self.slug})

class Note(models.Model):
  title               = models.CharField(max_length=255, blank=True)
  content             = models.TextField(blank=True, help_text='Markdown Supported')
  # Meta
  date_modified       = models.DateTimeField(auto_now=True)
  date_created        = models.DateTimeField(auto_now_add=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE)
  # Relations
  people              = models.ManyToManyField(Person, blank=True, related_name='notes')
  tag                 = models.ManyToManyField(Tag, blank=True, related_name='notes')
  
  def __str__(self):
    return self.title
  def get_absolute_url(self):
        return reverse('archive:note', kwargs={'pk': self.pk})

class Group(models.Model):
  title               = models.CharField(max_length=255, blank=True)
  description         = models.CharField(max_length=512, blank=True, null=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE)
  tag                 = models.ManyToManyField(Tag, blank=True, related_name='groups')
  def __str__(self):
    title = self.title
    if self.description:
      title += ' (' + self.description[:32]
      if len(self.description) > 32:
        title += '...'
      self.title += ')'
    return title

class Attachment(models.Model):
  file                = models.FileField(null=True, blank=True, upload_to='files', help_text='Possible to attach file to an image. Use for pdf, doc, excel, etc.')
  desciption          = models.CharField(max_length=512, blank=True, null=True)
  # Meta
  uploaded_at         = models.DateTimeField(auto_now_add=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE)


class Image(models.Model):
  # Document details
  source              = models.ImageField()
  thumbnail           = models.CharField(max_length=2000, blank=True, null=True)
  title               = models.CharField(max_length=255)
  show_in_index       = models.BooleanField(default=True)
  description         = models.TextField(blank=True, help_text='Markdown supported')
  document_source     = models.CharField(max_length=255, blank=True, help_text='Link or textual description of source')
  # Relations
  people              = models.ManyToManyField(Person, blank=True, related_name='images', help_text='Tag people that are on the photo')
  tag                 = models.ManyToManyField(Tag, blank=True, related_name='images')
  attachment          = models.FileField(null=True, blank=True, upload_to='files', help_text='Possible to attach file to an image. Use for pdf, doc, excel, etc.')
  attachments         = models.ManyToManyField(Attachment, blank=True, related_name='images')
  is_portrait_of      = models.OneToOneField(Person, on_delete=models.CASCADE, related_name='portrait', blank=True, null=True)
  in_group            = models.ManyToManyField(Group, blank=True, related_name='images', help_text='Group images')
  # Dating
  year                = models.PositiveSmallIntegerField(blank=True, null=True, help_text='Is automatically filled when date is supplied')
  date                = models.DateField(null=True, blank=True, help_text='Format: year-month-date, for example 1981-08-11')
  # Meta
  uploaded_at         = models.DateTimeField(auto_now_add=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE)
  is_deleted          = models.BooleanField(default=False)

  def __str__(self):
    return self.get_indexed_name()
    
  def get_indexed_name(self):
    title = self.title if self.title != '' else '--no title--'
    id = str(self.id)
    while len(id) < 4:
      id = '0' + id
    if self.is_deleted:
      title += ' (deleted)'
    return id + ' ' + title
  
  def count_tags(self):
    return self.tag.count()
  def count_people(self):
    return self.people.count()
  def has_thumbnail(self):
    return True if self.thumbnail else False
  def get_year(self):
    return self.date.year if self.date else self.year
  def count_images(self):
    return self.images.count()
  def get_attachment_type(self):
    if not self.attachment:
      return None
    elif self.attachment.name[-4:].lower() == '.pdf':
      return 'pdf'
    elif self.attachment.name[-4:].lower() == '.doc' or self.attachment.name[-5:].lower() == '.docx':
      return 'word'
    elif self.attachment.name[-4:].lower() == '.xls' or self.attachment.name[-5:].lower() == '.xlsx':
      return 'excel'
    elif self.attachment.name[-4:].lower() == '.jpg' or self.attachment.name[-5:].lower() == '.jpeg':
      return 'jpeg'
    elif self.attachment.name[-4:].lower() == '.png':
      return 'png'
    elif self.attachment.name[-4:].lower() == '.txt':
      return 'txt'
    elif self.attachment.name[-4:].lower() == '.csv':
      return 'csv'
    else:
      return 'unknown'

  def get_absolute_url(self):
    #return "/image/%i/" % self.pk
    return reverse('archive:image', kwargs={'pk': self.pk, 'name': self.title })  

  def save(self, commit=True, *args, **kwargs):
    # Fill in year if date is known
    if not self.year and self.date:
      self.year = int(self.date.year)
    # Generate thumbnail
    if self.source and not self.thumbnail:
      self.thumbnail = get_thumbnail(self.source)
    # Populate linked images
    # I've tried this, but changing a m2m relation in save() does not seem possible :(
    # Save
    return super(Image, self).save(*args, **kwargs)

class Comment(models.Model):
  # Meta
  date_modified       = models.DateTimeField(auto_now=True)
  date_created        = models.DateTimeField(auto_now_add=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE, related_name='comments')
  # Content
  content             = models.TextField(help_text='Markdown supported')
  image               = models.ForeignKey(Image, related_name='comments', on_delete=models.CASCADE)
  def __str__(self):
    return self.user.username + ' on ' + self.image.title
  def get_absolute_url(self):
    return "/image/%i/" % self.image.id
    #return reverse('documents-short', kwargs={'pk': self.image.id})




class TmpDoc(models.Model):
  # Document details
  source              = models.ImageField(upload_to='tmp')
  #thumbnail           = models.CharField(max_length=2000, blank=True, null=True)
  title               = models.CharField(max_length=255)
  show_in_index       = models.BooleanField(default=True)
  #description         = models.TextField(blank=True, help_text='Markdown supported')
  #document_source     = models.CharField(max_length=255, blank=True, help_text='Link or textual description of source')
  # Relations
  # people              = models.ManyToManyField(Person, blank=True, related_name='documents', help_text='Tag people that are on the photo')
  # tag                 = models.ManyToManyField(Tag, blank=True, related_name='documents')
  # images              = models.ManyToManyField("self", blank=True, help_text='Link another image to this one to create an image set')
  # attachment          = models.FileField(null=True, blank=True, upload_to='files', help_text='Possible to attach file to an image. Use for pdf, doc, excel, etc.')
  # Dating
  year                = models.PositiveSmallIntegerField(blank=True, null=True, help_text='Is automatically filled when date is supplied')
  date                = models.DateField(null=True, blank=True, help_text='Format: year-month-date, for example 1981-08-11')
  # Meta
  uploaded_at         = models.DateTimeField(auto_now_add=True)
  user                = models.ForeignKey(User, on_delete=models.CASCADE)

  def __str__(self):
    title = self.title if self.title != '' else '--no title--'
    return title
  def get_absolute_url(self):
    return '/upload/'